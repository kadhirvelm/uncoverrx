# UncoverRx

## Summary

This product helps scientists find small molecules relevant to their drug screen by leveraging the power of large language models. It relies on the ability of LLMs to traverse large, complex, and unstructured data, in this case specifically for exploring small molecules.

It integrates many data sources together in order to provide a unified solution for drug hunters to find molecules of interest.

## Background

See the full exploration here: (UncoverRx exploration)[https://docs.google.com/document/d/1iJTsa8id6nfXLzbZpv6i_pVlgPgVRVEbG-IZdvDP6nM/edit#]

## How this works under the hood

### LLM / Coordinator

This is the main Django application that houses the celery based coordinator for all the requests coming in from the user. It's the main system that takes in a user request, and sends it to the main worker. It also contains the primary schema used by all the coordinators and the frontend.

## LLM / ChatGPT

The celery worker for the ChatGPT functions. In the future there will be more and more of these workers that take in a similar request and spit out

## LLM / Library

The shared utilities between the Coordinator and all of its celery workers. This is where core utilities are declared, the models, instantiating celery instances, etc.

### Boundary

This holds two things, the API boundary definition of Coordinator and the shared object definitions for all services.

The API boundary definition is generated by running `yarn build` in the Boundary package, which pulls the API definitions declared by django-ninja from the Coordinator application into openapi.json. Then it runs a second script that takes the definition in openapi.json and generates a schema.ts, which it then copies into User/packages/backend, giving the User facing application access to a typesafe boundary to talk to Coordinator.

The second is the constants.json file, which is an openapi JSON declaration of shared constant objects. It uses `quicktype` to generate the shared definitions into python and typescript for use by all systems. This can be regenerated by editing `constants.json` and running `yarn constants`.

### User

Note: be sure to select "Use workspace version" for the typescript version VSCode is picking up in order to find the type definitions.

This uses yarn 3 to manage the Plug-N-Play modules, speeding up the build times all around by not needing to continuously redownload the modules at every turn. This was essential to getting a good docker-development experience.

User contains several packages, namely:

- API --> The shared API definition between the backend and the frontend
- Backend --> The express backend that handles hosting the frontend as well as responding to user requests
- Frontend --> The React layer, the side the user sees
- Prisma-Client --> The client that lets us interface with the database. It has its types autogenerated by pulling from the database, which can be regenerated using `yarn update`
- SCSS-modules --> This is added to the webpack definition in Frontend, allowing us to create type definitions for our SCSS modules
